## 4.1 Начало и завершение модулей

Модули ядра Linux отличаются от обычных пользовательских программ тем, что они не начинаются с функции `main()`. Вместо этого они используют две ключевые функции: инициализации и завершения работы, которые объявляются с помощью макросов `module_init()` и `module_exit()`, соответственно.

- **Инициализация модуля:** Функция инициализации модуля выполняется при загрузке модуля в ядро и может выполнять необходимые подготовительные действия, такие как регистрация устройств, создание файлов устройств и т.д. Эта функция должна быть зарегистрирована с помощью макроса `module_init()`.

- **Завершение модуля:** После того как модуль больше не требуется или система выключается, вызывается функция завершения, которая регистрируется с помощью макроса `module_exit()`. Эта функция должна отменять все действия, выполненные функцией инициализации, освобождая ресурсы, такие как память или сетевые порты.

## 4.2 Функции, доступные модулям

Модули ядра не могут использовать стандартные функции из библиотеки пользовательского пространства, такие как `printf()`, поскольку они выполняются в пространстве ядра. Вместо этого используется набор специализированных функций, доступных только в контексте ядра:

- **Вывод сообщений:** Для логирования сообщений в модуле ядра используется функция `pr_info()`. Эта функция аналогична `printf()`, но работает в пространстве ядра и поддерживает разные уровни логирования: `pr_info()`, `pr_err()`, `pr_warn()` и т.д.

- **Работа с памятью:** Для выделения и освобождения памяти в модуле ядра используются функции, такие как `kmalloc()`, `kfree()`, и для выделения памяти с сохранением страницы в случае работы с буферами ядра — `vmalloc()`.

- **Обработка ошибок:** Модули могут использовать различные механизмы для обработки ошибок, такие как возвращаемые коды ошибок или обработчики исключений.

## 4.3 Пользовательское пространство и пространство ядра

Операционная система Linux использует два режима работы процессора:

- **Режим пользователя** — это режим, в котором выполняются обычные приложения. В этом режиме приложения могут обращаться к системным вызовам для взаимодействия с ядром.

- **Режим ядра** — это привилегированный режим, в котором выполняются операционные системы, драйверы устройств и модули ядра. В этом режиме модули могут напрямую управлять ресурсами системы, такими как память, процессоры, устройства ввода-вывода и другие.


Модули ядра всегда работают в режиме ядра и могут выполнять низкоуровневые операции, такие как управление аппаратными устройствами, но при этом их ошибки могут существенно повлиять на стабильность всей системы. Важно, чтобы код в модулях был тщательно протестирован, поскольку сбой может привести к отказу системы.


## 4.4 Пространство имён

Модули ядра должны избегать загрязнения пространства имён, поскольку все модули работают в одном контексте ядра. Для этого важно:

- **Использовать статические переменные:** Это помогает избежать конфликтов с другими модулями, которые могут использовать те же имена символов.

- **Префиксы для символов:** Рекомендуется использовать уникальные префиксы для функций и переменных. Например, если разрабатывается модуль для работы с сетевым устройством, можно использовать префикс `net_` или `mymodule_`.

- **Таблицы символов:** Модули могут регистрировать свои символы в таблице символов через ядро, чтобы избежать случайных конфликтов.\

## 4.5 Кодовое пространство

Модули ядра выполняются в том же кодовом пространстве, что и ядро, а это значит, что все ошибки, такие как ошибки сегментации, которые происходят в модуле, могут повлиять на стабильность всей системы.

- **Ошибки в коде модуля:** Если модуль вызывает ошибку сегментации (например, при обращении к неинициализированной памяти), это может привести к панике ядра. Чтобы избежать таких ситуаций, важно следить за корректностью работы всех указателей и проверять выделенные ресурсы на ошибки.

- **Отсутствие своей памяти:** В отличие от пользовательских приложений, модули не имеют собственного адресного пространства и могут напрямую воздействовать на ресурсы системы.

## 4.6 Драйверы устройств

Драйверы устройств — это тип модуля, который управляет аппаратным обеспечением и предоставляет интерфейсы для пользовательских программ. Драйверы устройств могут работать с такими устройствами, как диски, звуковые карты, сетевые интерфейсы и другие.

Каждое устройство в Linux представлено файлом в каталоге `/dev`, и этот файл предоставляет интерфейс для взаимодействия с устройством. Например, драйвер для звуковой карты может предоставить файл `/dev/sound`, через который пользовательские программы могут читать и записывать данные.

- **Работа с файлами устройств:** Для работы с файлами устройств используется интерфейс `open()`, `read()`, `write()`, и т.д. Эти системные вызовы используются для взаимодействия с драйверами устройств.

- **Номера устройств:** Каждое устройство имеет два номера — старший и младший, которые используются для идентификации устройства и его драйвера. Старший номер указывает на тип устройства, а младший — на конкретное устройство.    

Пример кода для создания устройства:
```C
#include <linux/fs.h>

static struct file_operations my_device_fops = {
    .owner = THIS_MODULE,
    .open = my_device_open,
    .read = my_device_read,
};

static int __init my_driver_init(void)
{
    int result = register_chrdev(0, "my_device", &my_device_fops);
    if (result < 0) {
        pr_err("Failed to register device\n");
        return result;
    }
    pr_info("Driver loaded, device registered\n");
    return 0;
}
```


### 4.6.1 Мажорный и минорный номера устройств

Мажорный и минорный номера устройств в Linux играют ключевую роль в системе управления устройствами. Эти номера используются для уникальной идентификации устройств и их драйверов, а также для создания интерфейса для взаимодействия между пользовательскими программами и устройствами через файлы устройств.

#### Мажорный номер устройства

Мажорный номер — это уникальный идентификатор типа устройства или драйвера устройства. Все устройства одного типа, например, все блочные устройства или все символические устройства, имеют один и тот же мажорный номер. Мажорный номер связывает устройство с его драйвером, а не с конкретным экземпляром устройства.

- **Задача мажорного номера:** Он указывает на драйвер, который обслуживает устройство. Когда программа пытается открыть файл устройства, ядро ищет драйвер, связанный с этим мажорным номером, и перенаправляет запрос к соответствующему драйверу.

- **Пример:** Допустим, мажорный номер для всех блоковых устройств (например, жестких дисков) может быть одинаковым. В таком случае, драйвер для работы с жесткими дисками будет обрабатывать все устройства с этим мажорным номером, но при этом минорный номер будет определять, о каком конкретно устройстве идет речь.


#### Минорный номер устройства

Минорный номер — это уникальный идентификатор конкретного устройства, управляемого драйвером. Минорный номер используется для различения нескольких устройств, обслуживаемых одним и тем же драйвером. Он позволяет идентифицировать конкретный экземпляр устройства среди нескольких устройств одного типа.

- **Задача минорного номера:** Минорный номер позволяет драйверу различать устройства, например, разные разделы на одном жестком диске или разные порты на одном устройстве. Когда программа запрашивает доступ к устройству, минорный номер используется для указания конкретного устройства в рамках одного типа.

- **Пример:** На одном жестком диске могут быть несколько разделов, и каждый раздел будет иметь свой уникальный минорный номер, несмотря на то, что все они будут управляться одним и тем же драйвером для жестких дисков.


#### Как работает система мажорных и минорных номеров

Когда создается файл устройства (например, `/dev/sda1` для первого раздела на первом жестком диске), система использует пару мажорного и минорного номеров для определения того, какой драйвер и какой конкретный экземпляр устройства обрабатывают запросы.

- **Мажорный номер** используется для поиска соответствующего драйвера устройства.
- **Минорный номер** позволяет драйверу различать разные экземпляры устройств или их части.

Пример:

- `/dev/sda` — это файл устройства для жесткого диска (где `sda` — это имя устройства).
    
    - Мажорный номер может быть `8`, что указывает на драйвер для SCSI-устройств (в том числе и для жестких дисков).
    - Минорный номер будет `0`, что указывает на первый жесткий диск.
- `/dev/sda1` — это файл устройства для первого раздела на жестком диске.
    
    - Мажорный номер снова будет `8` (для SCSI-дисков).
    - Минорный номер будет `1`, что указывает на первый раздел этого жесткого диска.

#### Как узнать мажорный и минорный номера устройств

Для просмотра мажорных и минорных номеров устройств можно использовать команду `ls -l` в каталоге `/dev`:

```bash
ls -al /dev/sd*
brw-rw---- 1 root disk 8,  0 ноя 11 13:51 /dev/sda
brw-rw---- 1 root disk 8,  1 ноя 11 13:51 /dev/sda1
brw-rw---- 1 root disk 8,  2 ноя 11 13:51 /dev/sda2
brw-rw---- 1 root disk 8,  3 ноя 11 13:51 /dev/sda3
brw-rw---- 1 root disk 8, 16 ноя 11 13:51 /dev/sdb
```
В этом примере:

- Мажорный номер — `8`, минорный номер — `0` для устройства `/dev/sda` (первый диск).
- Мажорный номер — `8`, минорный номер — `1` для устройства `/dev/sda1` (первый раздел). 
- И т.д.

#### Регистрация устройств с мажорными и минорными номерами

При регистрации устройства в ядре Linux для создания интерфейса с пользователем, драйвер устройства использует функцию `register_chrdev()` для символических устройств или `register_blkdev()` для блочных устройств. Эти функции связывают устройство с мажорным номером.

Пример регистрации символического устройства:
 ```C
#include <linux/fs.h>
#include <linux/kernel.h>

static int major_num = 0;  // Мажорный номер

static int __init my_driver_init(void)
{
    major_num = register_chrdev(0, "my_device", &my_device_fops);
    if (major_num < 0) {
        pr_err("Failed to register device\n");
        return major_num;
    }
    pr_info("Device registered with major number %d\n", major_num);
    return 0;
}
```
Здесь `register_chrdev()` автоматически назначает мажорный номер, если передается `0` вместо конкретного номера.

#### Важность правильного распределения мажорных и минорных номеров

В ядре Linux существует система, которая следит за использованием мажорных и минорных номеров, чтобы избежать конфликтов между драйверами. Для символических устройств (например, для терминалов, устройств ввода-вывода) и блочных устройств (например, для дисков или сетевых интерфейсов) существует своя собственная область мажорных номеров.

- Для символических устройств используется диапазон номеров от 0 до 255, которые назначаются драйверам с использованием `register_chrdev()`.
- Для блочных устройств используется диапазон, начинающийся с 0 и продолжающийся в зависимости от типа устройства.

Когда создается новый драйвер, важно проверить, не используется ли уже данный мажорный номер другим драйвером, чтобы избежать конфликтов.

#### Пример работы с мажорными и минорными номерами

Допустим, мы пишем драйвер для симуляции устройства, например, для создания простого устройства, которое будет отображаться как `/dev/mydevice`. Мы можем создать мажорный номер 240 и минорный номер 0 для этого устройства:
```C
#include <linux/module.h>
#include <linux/fs.h>

#define MY_MAJOR 240
#define MY_MINOR 0

static int my_open(struct inode *inode, struct file *file)
{
    pr_info("My device opened.\n");
    return 0;
}

static struct file_operations my_fops = {
    .open = my_open,
};

static int __init my_driver_init(void)
{
    int ret;

    ret = register_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR), 1, "mydevice");
    if (ret < 0) {
        pr_err("Failed to register device\n");
        return ret;
    }
    
    pr_info("Device registered with major number %d and minor number %d\n", MY_MAJOR, MY_MINOR);
    return 0;
}

static void __exit my_driver_exit(void)
{
    unregister_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR), 1);
    pr_info("Device unregistered\n");
}

module_init(my_driver_init);
module_exit(my_driver_exit);

MODULE_LICENSE("GPL");
```
Здесь мы вручную задаем мажорный номер (240) и минорный номер (0). Команда `register_chrdev_region()` регистрирует пару мажорного и минорного номеров для устройства, и ядро будет использовать эти номера для связывания устройства с соответствующим драйвером.

Для хранения номеров устройств, обоих, старшего и младшего, в ядре используется тип dev_t (определённый в `<linux/types.h>`). Начиная с версии ядра 2.6.0, `dev_t` является 32-х разрядным, 12 бит отведены для старшего номера и 20 - для младшего. Ваш код, конечно, никогда не должен делать никаких предположений о внутренней организации номеров устройств; наоборот, он должен использовать набор макросов, находящихся в `<linux/kdev_t.h>`. Для получения старшей или младшей части dev_t используйте: 

```C
MAJOR(dev_t dev); 
MINOR(dev_t dev); 
```

Наоборот, если у вас есть старший и младший номера и необходимость превратить их в dev_t, используйте: 

```C
MKDEV(int major, int minor);
```

Важные замечания:
	- Если вы хотите избежать конфликта с уже зарегистрированными номерами, можно использовать `register_chrdev()` вместо `register_chrdev_region()` для динамического назначения мажорного номера.
	- Для проверки сообщений, можно использовать команду `dmesg`, чтобы увидеть вывод, который будет появляться при загрузке и выгрузке модуля.