 ### 2.1. Основные концепции модуля ядра

- **Модуль ядра** — это отдельный блок кода, который можно загружать в ядро динамически, чтобы расширить его функциональность, или выгружать, освобождая ресурсы.
- Преимущества модулей ядра:
    - **Гибкость**: модули можно добавлять и удалять без перезагрузки системы.
    - **Экономия ресурсов**: загружаются только необходимые модули, освобождая память и другие ресурсы.
    - **Безопасность и изоляция**: код модуля работает на уровне ядра, требуя осторожности, чтобы не нарушить работу системы.

### 2.2. Структура простого модуля ядра

Современная структура модуля ядра обычно включает:

1. **Функцию инициализации**, которая вызывается при загрузке модуля.
2. **Функцию завершения**, которая вызывается при выгрузке модуля.
3. **Макросы для регистрации функций инициализации и завершения** — `module_init()` и `module_exit()`.

#### Пример кода простого модуля на C

Ниже приведен код рабочего модуля `hello_world`, который использует актуальные макросы и структуру для современных версий ядра:

```C
#include <linux/module.h>  // Основные определения для модулей
#include <linux/kernel.h>  // Определения для KERN_INFO
#include <linux/init.h>    // Макросы для init и exit

// Функция, вызываемая при загрузке модуля
static int __init hello_init(void) {
    pr_info("Hello, world!\n");  // Используем pr_info вместо printk
    return 0;
}

// Функция, вызываемая при выгрузке модуля
static void __exit hello_exit(void) {
    pr_info("Goodbye, world!\n");
}

// Регистрируем функции инициализации и завершения
module_init(hello_init);
module_exit(hello_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Author Name");
MODULE_DESCRIPTION("A simple Hello World Module");
MODULE_VERSION("1.0");

```
### 2.3. Основные функции и макросы для работы с модулями

- **Функции журналирования**: современные версии ядра используют функции `pr_info()`, `pr_warn()`, `pr_err()` для сообщений разных уровней важности. Эти функции заменяют `printk()` с соответствующими флагами (`KERN_INFO`, `KERN_ERR` и т.д.).
    
    - **`pr_info()`** — информационные сообщения (аналог `printk(KERN_INFO ...)`).
    - **`pr_warn()`** — предупреждающие сообщения.
    - **`pr_err()`** — сообщения об ошибках.
    -  **`pr_debug()`** — используется для отладочных сообщений (работает только если включен флаг отладки в ядре).
- **`MODULE_LICENSE("GPL")`** — макрос, указывающий лицензию модуля. Использование GPL или совместимой лицензии предоставляет доступ к большему числу API функций ядра.
    
- **Макросы метаданных**:
    
    - `MODULE_AUTHOR`, `MODULE_DESCRIPTION`, `MODULE_VERSION` добавляют информацию, доступную через `modinfo`.
- **Атрибуты функции**:
    
    - `__init` и `__exit` добавляются к функциям инициализации и завершения для оптимизации использования памяти. Они освобождают память, используемую для инициализации, после завершения загрузки модуля.

### 2.4. Компиляция и загрузка модуля ядра

#### 2.4.1. Создание Makefile для модуля ядра

Makefile для сборки модуля ядра отличается от Makefile для обычных программ на C. Для модуля требуется make-система ядра, которая передает управление внутренней сборке ядра и использует особые переменные:

```makefile
# Название объекта модуля, который нужно собрать
obj-m += hello_world.o

# Основные команды сборки и очистки
all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean

```
#### Объяснение основных элементов Makefile:

- **`obj-m += hello_world.o`** — объявляет объект модуля для сборки (`hello_world.ko`). Можно указать несколько файлов через пробел.
- **`-C /lib/modules/$(shell uname -r)/build`** — `make -C` указывает использовать директорию сборки ядра (обычно `/lib/modules/$(uname -r)/build`), где расположены исходные файлы и скрипты ядра.
- **`M=$(PWD)`** — задает текущую директорию как `M`, позволяя make-системе ядра искать Makefile модуля здесь.
#### 2.4.2. Компиляция и загрузка модуля

Чтобы собрать модуль:
```bash
make
```

После этого в текущей папке появится скомпилированный модуль `hello_world.ko`.
#### 2.4.3. Загрузка и выгрузка модуля

- **Загрузка модуля**:
```bash 
  sudo insmod hello_world.ko
```
Загружает модуль в ядро и вызывает функцию `hello_init()`.

- **Выгрузка модуля**:
```bash
sudo rmmod hello_world
```
Выгружает модуль из ядра, вызывая функцию `hello_exit()`.

- **Проверка загруженных модулей**:
 ```bash
 lsmod | grep hello_world
```
Эта команда покажет, загружен ли модуль `hello_world`.

#### 2.4.4. Проверка логов ядра

Чтобы увидеть вывод от `pr_info()` и других сообщений из модуля, используйте:

```bash
dmesg | tail
```

```bash
sudo journalctl --since "1 hour ago" | grep kernel
```
### 2.5. Доступ к информации о модуле

- **Команда `modinfo`** показывает метаданные модуля, такие как автор, версия и описание, которые были определены с помощью макросов `MODULE_AUTHOR`, `MODULE_DESCRIPTION`, и `MODULE_VERSION`:

```bash
modinfo hello_world.ko
```



