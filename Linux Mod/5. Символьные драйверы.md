## 5.1. Введение в символьные драйверы

Символьные драйверы (character device drivers) обеспечивают интерфейс для устройств, которые обрабатывают данные посимвольно (или побайтно), а не в блоках, как блочные устройства. Этот тип драйверов широко используется для таких устройств, как последовательные порты, терминалы, виртуальные консоли и другие устройства, где требуется последовательный ввод и вывод данных.

### Ключевые характеристики символьных драйверов

1. **Последовательный доступ к данным**:
    
    - Символьные устройства позволяют читать и записывать данные последовательно, что удобно для потоков данных, передающихся последовательно.
    - Пример: символьные устройства не позволяют переходить по заданным смещениям, как это делают блочные устройства, ориентированные на массивы данных.
2. **Отсутствие буферизации на уровне драйвера**:
    
    - Символьные драйверы не реализуют автоматическую буферизацию. Данные записываются и читаются «как есть», что делает эти устройства подходящими для потоковой передачи данных (например, для последовательных портов).
    - Если требуется буферизация, её необходимо реализовать в самом драйвере.
3. **Пример использования**:
    
    - Символьные устройства часто работают с файлами в `/dev`, такими как `/dev/tty` для терминалов или `/dev/random` для генератора случайных чисел.
    - Эти устройства получают прямой доступ к аппаратному обеспечению, упрощая настройку и управление, но при этом взаимодействуют с ним на низком уровне.

### Зачем нужны символьные драйверы?

Символьные драйверы — это основной тип драйверов для устройств, требующих управления потоком данных. В отличие от блочных устройств, которые читают и записывают данные большими блоками, символьные устройства работают с минимальной задержкой, позволяя получать доступ к данным почти сразу. Они подходят для всех устройств, которые не имеют фиксированного размера или структуры данных, таких как:

- **Терминальные устройства**: управление текстовыми потоками ввода-вывода.
- **Порты**: последовательные и параллельные порты.
- **Псевдоустройства**: устройства, которые не имеют реальной аппаратной поддержки, такие как `/dev/null` или `/dev/zero`.

### Пример устройства, которое можно использовать как символьное

Возьмем устройство `/dev/tty0` — это стандартное терминальное устройство в UNIX-системах, предназначенное для взаимодействия с консолью. Когда приложение отправляет данные в `/dev/tty0`, они передаются напрямую на консоль, где данные отображаются. Это простейший пример символьного устройства, так как терминал передает данные посимвольно.

### Изменения и развитие подходов в символьных драйверах с момента написания книги LDD

С момента выхода книги _Linux Device Drivers_ (LDD) API для работы с символьными драйверами претерпел изменения, особенно в плане безопасности и удобства. Например:

- **Назначение номеров устройств**: вместо статического назначения используется динамическое выделение через `alloc_chrdev_region`.
- **Регистрация драйвера**: современные подходы включают использование `struct cdev`, а не старого `register_chrdev`.
- **Стандарты языка C**: функции были адаптированы к C99 и C11, включая возможность использования inline-функций и более строгих проверок типов.

Эти улучшения сделали код более переносимым и безопасным, что особенно важно в современных системах с частыми обновлениями ядра.

### Взаимосвязь с файловой системой

В Linux символьные устройства отображаются как файлы в файловой системе `/dev`, что позволяет к ним обращаться как к обычным файлам, используя стандартные системные вызовы `open`, `read`, `write` и `close`. Эти системные вызовы обрабатываются драйвером и обеспечивают взаимодействие между пользователем и устройством. Например, `open("/dev/mydevice")` вызывает функцию `open` драйвера, где происходит инициализация устройства, и система передает управление драйверу через таблицу операций `file_operations`.


## 5.2. Проектирование `scull` — простейшего символьного драйвера

`scull` (Simple Character Utility for Loading Localities) — это пример базового символьного драйвера, представленный в книге LDD. Он создан для иллюстрации фундаментальных концепций работы с символьными драйверами и для отработки базовых операций: регистрации устройства, работы с памятью, операций `read`, `write`, и т.д. В этом разделе мы разберем, как проектировать такой драйвер, и обсудим, какие аспекты необходимо учитывать при разработке символьных драйверов.

### Цели и задачи `scull`

Цель `scull` — обеспечить минимально возможную реализацию драйвера символьного устройства для обучения:

1. **Чтение и запись данных**: `scull` предоставляет базовые функции `read` и `write` для работы с устройством.
2. **Регистрация и управление устройствами**: `scull` иллюстрирует процесс регистрации устройства, включая выделение старшего и младшего номеров устройств и добавление устройства в файловую систему `/dev`.
3. **Работа с памятью**: демонстрируется управление буфером данных, который может расширяться динамически, как обычное символьное устройство (например, используя `kmalloc` и `kfree` для работы с памятью в Linux).

### Принципы и компоненты `scull`

1. **Буферы данных**:
    
    - `scull` хранит данные в виртуальной памяти, которая выступает в роли «буфера» для обмена данными между устройством и пользователем. Размер буфера может быть задан параметром, а в примере обычно устанавливается на 4 КБ.
    - Для реализации этого буфера часто используется `kmalloc` для динамического выделения памяти, что позволяет буферу менять размер при необходимости, а также демонстрирует механизм управления выделением и освобождением памяти.
2. **Старшие и младшие номера устройств**:
    
    - Устройства идентифицируются по старшему (major) и младшему (minor) номерам. `scull` регистрирует устройство и получает уникальный старший номер, используя `alloc_chrdev_region`. Младшие номера могут быть назначены для каждой отдельной «версии» устройства `scull`, что позволяет создать несколько экземпляров одного устройства.
    - Примерный вызов для регистрации номера устройства:
    ```C
	dev_t dev;
	int major;
	int result = alloc_chrdev_region(&dev, 0, 1, "scull");
	major = MAJOR(dev); // Извлекаем старший номер
	```
    - Использование динамического выделения номеров устройств делает драйвер более гибким и позволяет избежать конфликта с уже зарегистрированными номерами.
3. **Инициализация структуры `cdev`**:
    
    - Структура `cdev` представляет символьное устройство в ядре и используется для регистрации набора операций, которые устройство поддерживает.
    - Пример создания и регистрации структуры `cdev`:
        ```C
    struct cdev scull_cdev;
	cdev_init(&scull_cdev, &fops);
	scull_cdev.owner = THIS_MODULE;
	cdev_add(&scull_cdev, dev, 1);

		```
    - Структура `cdev` связывается с набором функций (`file_operations`), которые определяют поведение устройства при вызове стандартных операций, таких как `open`, `read`, `write` и `release`.
4. **Функции работы с устройством**:
    
    - `open`: выполняет инициализацию устройства, открывает доступ к буферу и возвращает дескриптор.
    - `release`: освобождает ресурсы, занятые устройством, и закрывает доступ к буферу.
    - `read` и `write`: реализуют основные функции обмена данными между пользователем и устройством.
5. **Потокобезопасность**:
    
    - Потокобезопасность важна, поскольку символьные драйверы могут быть использованы несколькими процессами одновременно. `scull` реализует механизм блокировок для защиты буферов и других общих ресурсов. Обычно используется `mutex` для синхронизации доступа к буферу:
		```C
	static DEFINE_MUTEX(scull_mutex);
	mutex_lock(&scull_mutex);
	// Доступ к общим ресурсам
	mutex_unlock(&scull_mutex);
		```

### Структура файла и регистрация устройства

`scull` требует создания файла устройства в `/dev`, чтобы пользовательские программы могли к нему обращаться:

```bash
mknod /dev/scull c <major> 0
chmod 666 /dev/scull
```
Где `<major>` — старший номер устройства, который возвращается после вызова `alloc_chrdev_region`.


## 5.3. Старший и младший номера устройств

Старший и младший номера устройств — это два числа, используемые для идентификации устройств в Linux. Они помогают системе связать устройство с его драйвером и позволяют обращаться к конкретному устройству через файловую систему.

### 1. Роль старшего и младшего номеров устройств

- **Старший номер устройства (Major Number)**: определяет драйвер, который управляет устройством. Когда операционная система обращается к устройству, она использует старший номер, чтобы найти соответствующий драйвер. Драйверу присваивается уникальный старший номер, который связывает его с определенным типом устройств.

- **Младший номер устройства (Minor Number)**: позволяет драйверу различать отдельные устройства или экземпляры устройств, управляемых этим драйвером. Например, драйвер для символьного устройства может иметь несколько устройств, у каждого из которых будет уникальный младший номер, но общий старший.


### 2. Назначение старшего и младшего номеров в драйвере

В `scull` и в других драйверах Linux можно назначать номера устройств статически или динамически. Динамическое выделение упрощает разработку и помогает избежать конфликтов, когда старший номер уже занят другим устройством.

#### Динамическое выделение номеров

В современном Linux, номера устройств можно динамически выделить с помощью `alloc_chrdev_region`, которая выделяет диапазон номеров для устройства и возвращает `dev_t` — объединённое значение старшего и младшего номеров.

```C
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, const char *name);
```
- **dev** — указатель на переменную для хранения номера устройства (мажорного и минорного).
- **firstminor** — первый минорный номер устройства, который будет назначен (обычно начинается с 0).
- **count** — количество устройств, для которых нужно выделить номера.
- **name** — имя устройства.

Пример выделения номера:
```C
dev_t dev;
int major;
int result = alloc_chrdev_region(&dev, 0, 1, "scull"); // выделяем один младший номер
if (result < 0) {
    printk(KERN_WARNING "scull: не удалось зарегистрировать номер устройства\n");
    return result;
}
major = MAJOR(dev); // извлекаем старший номер
```

 В этом примере `dev` — это переменная типа `dev_t`, хранящая старший и младший номера, а `major` хранит выделенный старший номер. Функция `alloc_chrdev_region` выделяет `1` младший номер для устройства `scull` и связывает его с названием устройства, которое можно увидеть в `/proc/devices`.

#### Статическое выделение номеров

 Иногда старший номер задается вручную, чтобы гарантировать, что устройство всегда будет иметь определенный номер. Для этого используют `MKDEV`, которая создает `dev_t` на основе старшего и младшего номеров:
 
```C
dev_t dev = MKDEV(major, 0); // major — заданный вручную старший номер
```

После создания `dev` с `MKDEV`, можно вызвать `register_chrdev_region` для регистрации его в системе. Однако статическое выделение менее предпочтительно, так как требует контроля за уникальностью номеров.

### 3. Работа с `dev_t`

`dev_t` — это 32-битное целое число, объединяющее старший и младший номера. С помощью макросов можно разделить или объединить старший и младший номера:

- **MAJOR(dev)** — извлекает старший номер.
- **MINOR(dev)** — извлекает младший номер.
- **MKDEV(major, minor)** — объединяет старший и младший номера в одно значение `dev_t`.

### 4. Освобождение номеров

После завершения работы драйвера необходимо освободить выделенные номера. Это предотвращает конфликты и повторное использование тех же номеров другими устройствами.

```C
unregister_chrdev_region(dev, 1);
```

Здесь `dev` — это тот же `dev_t`, который был использован при регистрации, а `1` — количество младших номеров, выделенных для устройства.



## 5.4. Некоторые важные структуры данных

Работа с символьными устройствами в Linux требует использования ряда структур данных, которые обеспечивают интерфейс между драйвером и операционной системой. Понимание этих структур данных необходимо для создания стабильного и производительного драйвера.

### 1. Структура `file_operations`

`file_operations` — это основная структура, используемая для управления символьными устройствами. Она содержит указатели на функции, которые реализуют основные операции с устройством, такие как `open`, `read`, `write`, `release` и другие. Каждое символьное устройство должно зарегистрировать `file_operations`, чтобы ядро знало, как с ним работать.

#### Структура `file_operations` включает:

- **open** — функция, вызываемая при открытии устройства.
- **release** — вызывается при закрытии устройства.
- **read** — считывает данные с устройства в пространство пользователя.
- **write** — записывает данные из пространства пользователя на устройство.
- **ioctl** — выполняет различные команды управления устройством.
- **llseek** — изменяет текущую позицию в файле для устройства.

Пример инициализации структуры `file_operations`:

```C
static struct file_operations scull_fops = {
    .owner = THIS_MODULE,
    .open = scull_open,
    .release = scull_release,
    .read = scull_read,
    .write = scull_write,
    .unlocked_ioctl = scull_ioctl
};
```

Поле `.owner` (`THIS_MODULE`) используется для увеличения счетчика ссылок на модуль, когда устройство открыто, что предотвращает выгрузку модуля во время работы с устройством.

### 2. Структура `file`

`file` — это структура, представляющая открытый файл в Linux. Когда процесс открывает файл, ядро создает объект `file`, который содержит информацию о состоянии этого открытого файла (например, текущую позицию для чтения или записи). Она передается в функции `read`, `write`, `open`, `release` и другие функции, связанные с работой с устройством.

Некоторые важные поля:

- **f_op** — указывает на структуру `file_operations`, связанную с этим устройством.
- **f_flags** — флаги, переданные при открытии файла (например, режимы чтения или записи).
- **private_data** — указатель для хранения дополнительных данных драйвера, уникальных для этого конкретного открытия.

Использование `private_data` позволяет привязать к файлу структуры или данные, которые будут использоваться только в этом конкретном экземпляре.

Пример работы с `private_data`:

```C
static int scull_open(struct inode *inode, struct file *filp) {
    struct scull_dev *dev = container_of(inode->i_cdev, struct scull_dev, cdev);
    filp->private_data = dev;
    return 0;
}
```

Здесь мы связываем `filp->private_data` с устройством `scull_dev`, чтобы иметь доступ к данным устройства через указатель `filp` в других функциях, например, `read` или `write`.

### 3. Структура `inode`

`inode` — структура, которая содержит метаданные о файле или устройстве, такие как его тип и права доступа. Когда устройство открывается, драйвер может использовать `inode` для идентификации экземпляра устройства.

Некоторые ключевые поля:

- **i_cdev** — указывает на структуру `cdev`, представляющую устройство.
- **i_rdev** — объединенное значение старшего и младшего номера устройства.

Используя поле `i_cdev`, можно получить доступ к данным, связанным с конкретным устройством, как это показано в примере выше.

Тип `i_rdev` изменился в течение серии разработки ядра версии 2.5, поломав множество драйверов. В качестве средства поощрения более переносимого программирования разработчики ядра добавили два макроса, которые могут быть использованы для получения старшего и младшего номера inode:

```C
unsigned int iminor(struct inode *inode); 
unsigned int imajor(struct inode *inode);
```

В интересах не быть пойманными следующими изменениями, вместо манипулирования i_rdev напрямую должны быть использованы эти макросы.

### 4. Структура `cdev`

`cdev` — это структура, которая представляет символьное устройство в ядре. Она регистрируется в системе с помощью функций `cdev_init` и `cdev_add`, связывая символьное устройство с его функциями `file_operations`.

Основные шаги для использования `cdev`:

1. Инициализация структуры `cdev` с помощью `cdev_init`, привязывая ее к структуре `file_operations`.
2. Регистрация структуры `cdev` в системе с помощью `cdev_add`.

Пример инициализации и регистрации `cdev`:

```C
static struct cdev scull_cdev;

static int __init scull_init(void) {
    dev_t dev;
    int result;

    // Выделение номера устройства
    result = alloc_chrdev_region(&dev, 0, 1, "scull");
    if (result < 0) {
        printk(KERN_WARNING "scull: не удалось зарегистрировать номер устройства\n");
        return result;
    }

    // Инициализация cdev
    cdev_init(&scull_cdev, &scull_fops);
    scull_cdev.owner = THIS_MODULE;

    // Регистрация устройства в системе
    result = cdev_add(&scull_cdev, dev, 1);
    if (result) {
        printk(KERN_NOTICE "Ошибка %d при добавлении scull\n", result);
        unregister_chrdev_region(dev, 1);
    }
    return result;
}
```
В этом примере `scull_cdev` связывается с функциями `scull_fops` и регистрируется в системе. Эта структура `cdev` позволяет ядру знать, какие функции нужно вызывать при взаимодействии с устройством.
- **cdev_init** — инициализирует структуру `cdev`, связывая её с операциями, описанными в `file_operations`.
- **cdev_add** — добавляет `cdev` в систему, привязывая устройство к мажорному номеру и указывая количество устройств.

## 5.5. Регистрация символьных устройств

Регистрация символьного устройства в ядре — это процесс, при котором ядро узнает о наличии устройства и привязывает его к набору операций, определённых в структуре `file_operations`. Для того чтобы устройство стало доступным для работы с пользователем, необходимо выполнить несколько шагов:

### 1. Выделение номера устройства

Прежде чем создать символьное устройство, необходимо получить уникальные номера устройства (мажорный и минорный), которые будут использоваться для идентификации устройства в системе. Это можно сделать с помощью функции `alloc_chrdev_region`.
```C
dev_t dev;
int result = alloc_chrdev_region(&dev, 0, 1, "scull");
if (result < 0) {
    printk(KERN_WARNING "scull: не удалось зарегистрировать номер устройства\n");
    return result;
}
```
### 2. Инициализация и регистрация структуры `cdev`

После того как мы получили номер устройства, необходимо инициализировать структуру `cdev` и зарегистрировать её в системе. Для этого используется функция `cdev_init`, которая связывает структуру `cdev` с функциями в `file_operations`, а затем — `cdev_add`, чтобы зарегистрировать устройство в системе.
```C
static struct cdev scull_cdev;
cdev_init(&scull_cdev, &scull_fops);
scull_cdev.owner = THIS_MODULE;

int result = cdev_add(&scull_cdev, dev, 1);
if (result) {
    printk(KERN_NOTICE "Ошибка %d при добавлении scull\n", result);
    unregister_chrdev_region(dev, 1);
}
```

### 3. Регистрация класса устройства

Хотя устройство уже зарегистрировано в ядре, для того чтобы оно стало доступным в пространстве пользователя, необходимо зарегистрировать класс устройства. Это сделает его видимым в директории `/dev`.

Для регистрации класса устройства используется функция `class_create`, которая принимает имя устройства и возвращает указатель на структуру `class`. Эту структуру можно использовать для создания и удаления устройств.

```C
static struct class *scull_class;
scull_class = class_create(THIS_MODULE, "scull");
if (IS_ERR(scull_class)) {
    printk(KERN_WARNING "scull: не удалось создать класс устройства\n");
    return PTR_ERR(scull_class);
}
```

### 4. Создание устройства в `/dev`

После того как класс устройства зарегистрирован, можно создать соответствующий файл устройства в директории `/dev` с помощью функции `device_create`. Эта функция принимает класс устройства, указатель на устройство, мажорный и минорный номера, а также имя устройства.

```C
struct device *dev_ret;
dev_ret = device_create(scull_class, NULL, dev, NULL, "scull");
if (IS_ERR(dev_ret)) {
    printk(KERN_WARNING "scull: не удалось создать устройство\n");
    class_destroy(scull_class);
    unregister_chrdev_region(dev, 1);
    return PTR_ERR(dev_ret);
}
```

* **device_create** — создает файл устройства в `/dev` с заданным именем (в данном примере `"scull"`).

### 5. Завершение регистрации

После того как устройство зарегистрировано и создан файл в `/dev`, нужно убедиться, что модуль корректно зарегистрирован в системе, и его можно будет использовать. Для этого в функции инициализации модуля после всех действий следует добавить вывод информации о состоянии устройства:

```C
printk(KERN_INFO "scull: устройство зарегистрировано, мажорный номер %d\n", MAJOR(dev));
```

### 6. Очистка и удаление устройства

После завершения работы с устройством необходимо освободить ресурсы и удалить устройство из системы. Для этого используется функция `device_destroy`, которая удаляет файл устройства из `/dev`, и `class_destroy`, которая удаляет класс.

```C
device_destroy(scull_class, dev);
class_destroy(scull_class);
unregister_chrdev_region(dev, 1);
cdev_del(&scull_cdev);
```

### Полный пример регистрации устройства

```C
#include <linux/module.h>         // Основной заголовок для работы с модулями ядра
#include <linux/kernel.h>         // Для использования функций printk, pr_info, pr_err и других
#include <linux/init.h>           // Для макросов и функций инициализации модуля (module_init, module_exit)
#include <linux/fs.h>             // Для работы с файловыми системами и операциями устройства
#include <linux/cdev.h>           // Для создания и управления символьными устройствами (cdev, cdev_init, cdev_add)
#include <linux/device.h>         // Для работы с классами и устройствами (class_create, device_create, etc.)
#include <linux/uaccess.h>        // Для операций с пользовательской памятью (например, copy_to_user, copy_from_user)


#define DEVICE_NAME "scull"
static int major;
static struct cdev scull_cdev;
static struct class *scull_class;

static int scull_open(struct inode *inode, struct file *file)
{
    pr_info("scull: открытие устройства\n");
    return 0;
}

static int scull_release(struct inode *inode, struct file *file)
{
    pr_info("scull: закрытие устройства\n");
    return 0;
}

static ssize_t scull_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
{
    pr_info("scull: чтение данных\n");
    return 0;  // Пример. Реализация чтения будет зависеть от устройства
}

static ssize_t scull_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
    pr_info("scull: запись данных\n");
    return count;  // Пример. Реализация записи будет зависеть от устройства
}

static const struct file_operations scull_fops = {
    .owner = THIS_MODULE,
    .open = scull_open,
    .release = scull_release,
    .read = scull_read,
    .write = scull_write,
};

static int __init scull_init(void)
{
    dev_t dev;
    int result;

    // Выделение номера устройства
    result = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);
    if (result < 0) {
        pr_err("scull: не удалось зарегистрировать номер устройства\n");
        return result;
    }

    major = MAJOR(dev);

    // Инициализация cdev
    cdev_init(&scull_cdev, &scull_fops);
    scull_cdev.owner = THIS_MODULE;

    // Регистрация устройства в системе
    result = cdev_add(&scull_cdev, dev, 1);
    if (result) {
        pr_err("scull: ошибка при добавлении устройства\n");
        unregister_chrdev_region(dev, 1);
        return result;
    }

    // Регистрация класса устройства
    scull_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(scull_class)) {
        pr_err("scull: не удалось создать класс устройства\n");
        unregister_chrdev_region(dev, 1);
        return PTR_ERR(scull_class);
    }

    // Создание устройства в /dev
    struct device *dev_ret;
    dev_ret = device_create(scull_class, NULL, dev, NULL, DEVICE_NAME);
    if (IS_ERR(dev_ret)) {
        pr_err("scull: не удалось создать устройство\n");
        class_destroy(scull_class);
        unregister_chrdev_region(dev, 1);
        return PTR_ERR(dev_ret);
    }

    pr_info("scull: устройство зарегистрировано, мажорный номер %d\n", major);

    return 0;
}

static void __exit scull_exit(void)
{
    dev_t dev = MKDEV(major, 0);  // Получаем dev по мажорному номеру

    device_destroy(scull_class, dev);
    class_destroy(scull_class);
    unregister_chrdev_region(dev, 1);
    cdev_del(&scull_cdev);

    pr_info("scull: устройство удалено\n");
}

module_init(scull_init);
module_exit(scull_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Autor");
MODULE_DESCRIPTION("Пример символьного драйвера для устройства scull");
```

